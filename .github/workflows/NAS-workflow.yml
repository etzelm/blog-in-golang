name: blog-in-golang-nas
# This workflow deploys blog changes from my NAS

# Add the permissions block here
permissions:
  contents: read # Allows checkout and reading repository content

on:
  push:
    branches:
      - 'develop'
      - 'master'
  pull_request:
  workflow_dispatch:

jobs:

  NAS-build:
    # No specific token permissions needed beyond checkout
    if: github.ref != 'refs/heads/master' && github.ref != 'refs/heads/develop'
    runs-on: [self-hosted, Linux, X64, nas]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Build
        shell: bash
        run: |
          set -e
          set -o pipefail
          echo STARTING BUILD
          BRANCH=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}
          echo "BRANCH: $BRANCH"
          pushd realtor
          echo "React Build Starting"
          yarn install
          yarn test --coverage
          yarn build
          echo "React Build Finished"
          popd
          pushd blog
          echo "Golang Build Starting"
          go mod download
          go test
          CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -a -installsuffix cgo -o blog-in-golang .
          echo "Golang Build Finished"
          popd

  NAS-deploy:
    # No specific token permissions needed beyond checkout and changed-files
    if: github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop'
    runs-on: [self-hosted, Linux, X64, nas]
    env:
      NAS_ADDR: ${{ secrets.NAS_ADDR }}
      NAS_USER: ${{ secrets.NAS_USER }}
      NAS_PASS: ${{ secrets.NAS_PASS }}
      NAS_ARGS: ${{ secrets.NAS_ARGS }}
      NAS_DIR: ${{ secrets.NAS_DIR }}
      NAS_BIN: ${{ secrets.NAS_BIN }}
      GCP_ADDR: ${{ secrets.GCP_ADDR }}
      GCP_USER: ${{ secrets.GCP_USER }}
      GCP_PASS: ${{ secrets.GCP_PASS }}
      GCP_ARGS: ${{ secrets.GCP_ARGS }}
      GCP_DIR: ${{ secrets.GCP_DIR }}
      GCP_BIN: ${{ secrets.GCP_BIN }}
      GAPI: ${{ secrets.GAPI }}
      DISTRIBUTION_ID1: ${{ secrets.DISTRIBUTION_ID1 }}
      DISTRIBUTION_ID2: ${{ secrets.DISTRIBUTION_ID2 }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Get Changed Article Files
        id: changed-daemon-files
        uses: tj-actions/changed-files@v45
        with:
          files: |
            daemon/articles/**
            daemon/app.go
      - name: Get Changed Build Files
        id: changed-build-files
        uses: tj-actions/changed-files@v45
        with:
          files: |
            blog/go.mod
            blog/go.sum
            blog/app.go
            blog/Dockerfile
            blog/public/**
            blog/src/**
            blog/templates/**
            realtor/yarn.lock
            realtor/package.json
            realtor/public/**
            realtor/src/**
      - name: Push Article Changes
        if: steps.changed-daemon-files.outputs.any_changed == 'true'
        shell: bash
        run: |
          set -e
          set -o pipefail
          echo STARTING TO PUSH CHANGES TO ARTICLES
          BRANCH=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}
          echo "BRANCH: $BRANCH"
          if [[ $BRANCH == "master" ]]
          then
            export ARTICLES="Live-Articles"
          else
            export ARTICLES="Test-Articles"
          fi
          echo "Articles: ${ARTICLES}"
          pushd daemon
          for i in {0..4}
            do go run app.go $i
          done
          popd
      - name: Build & Deploy
        id: deploy
        if: steps.changed-build-files.outputs.any_changed == 'true'
        shell: bash
        run: |
          set -e
          set -o pipefail
          echo STARTING BUILD
          BRANCH=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}
          echo "BRANCH: $BRANCH"
          if [[ $BRANCH == "master" ]]
          then
            TAG="latest"
          else
            TAG="$BRANCH"
          fi
          echo "TAG: $TAG"
          echo BUILDING DOCKER IMAGE
          docker build --build-arg GAPI=$GAPI -t blog:$TAG -f blog/Dockerfile .
          echo DEPLOYING NAS DOCKER CONTAINER
          sshpass -p $NAS_PASS ssh $NAS_USER@$NAS_ADDR $NAS_ARGS -t "cd $NAS_DIR-$BRANCH; $NAS_BIN/docker compose up --force-recreate -d"
          if [[ $BRANCH == "master" ]]
          then
            echo DEPLOYING GCP DOCKER CONTAINER
            docker save blog:latest > blog.tar
            scp -i ~/.ssh/gcp_rsa $GCP_ARGS blog.tar $GCP_USER@$GCP_ADDR:$GCP_DIR.
            ssh -i ~/.ssh/gcp_rsa $GCP_ARGS $GCP_USER@$GCP_ADDR -t "cd $GCP_DIR; $GCP_BIN/docker load --input blog.tar"
            ssh -i ~/.ssh/gcp_rsa $GCP_ARGS $GCP_USER@$GCP_ADDR -t "cd $GCP_DIR; $GCP_BIN/docker compose up --force-recreate -d"
            ssh -i ~/.ssh/gcp_rsa $GCP_ARGS $GCP_USER@$GCP_ADDR -t "cd $GCP_DIR; $GCP_BIN/docker system prune -f"
            ssh -i ~/.ssh/gcp_rsa $GCP_ARGS $GCP_USER@$GCP_ADDR -t "cd $GCP_DIR; rm -rf blog.tar"
            INVALIDATION_ID1=$(aws cloudfront create-invalidation --distribution-id $DISTRIBUTION_ID1 --paths '/*' --query 'Invalidation.Id' --output text)
            INVALIDATION_ID2=$(aws cloudfront create-invalidation --distribution-id $DISTRIBUTION_ID2 --paths '/*' --query 'Invalidation.Id' --output text)
            STATUS1="InProgress"
            STATUS2="InProgress"
            while [[ "$STATUS1" == "InProgress" || "$STATUS2" == "InProgress" ]]; do
              sleep 5
              STATUS1=$(aws cloudfront get-invalidation --distribution-id $DISTRIBUTION_ID1 --id $INVALIDATION_ID1 --query 'Invalidation.Status' --output text)
              STATUS2=$(aws cloudfront get-invalidation --distribution-id $DISTRIBUTION_ID2 --id $INVALIDATION_ID2 --query 'Invalidation.Status' --output text)
              echo "Invalidation status 1: $STATUS1"
              echo "Invalidation status 2: $STATUS2"
            done
          fi
          docker system prune -f
      - name: Test
        if: steps.deploy.outcome == 'success' || steps.deploy.outcome == 'skipped'
        shell: bash
        run: |
          set -e
          set -o pipefail
          BRANCH=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}
          if [[ $BRANCH == "master" ]]
          then
            echo RUNNING TESTS TO CACHE CLOUDFRONT CONTENT
            TEST=.github/workflows/public-urls.txt
          else
            echo RUNNING TESTS
            TEST=.github/workflows/local-urls.txt
          fi
          while IFS= read -r line
          do
            echo $line
            command="curl --fail --header 'accept-encoding: gzip' "$line" > /dev/null"
            eval "$command"
          done < $TEST
